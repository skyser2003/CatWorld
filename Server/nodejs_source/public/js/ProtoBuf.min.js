/*
 ProtoBuf.js (c) 2013 Daniel Wirtz <dcode@dcode.io>
 Released under the Apache License, Version 2.0
 see: https://github.com/dcodeIO/ProtoBuf.js for details
*/
(function (p) {
    function q(m) {
        if (!m || !m.VERSION || 3 > m.VERSION.split(".")[0]) throw Error("ProtoBuf.js requires ByteBuffer.js >=3"); var g = { VERSION: "3.0.0-pre", WIRE_TYPES: {} }; g.WIRE_TYPES.VARINT = 0; g.WIRE_TYPES.BITS64 = 1; g.WIRE_TYPES.LDELIM = 2; g.WIRE_TYPES.STARTGROUP = 3; g.WIRE_TYPES.ENDGROUP = 4; g.WIRE_TYPES.BITS32 = 5; g.TYPES = {
            int32: { name: "int32", wireType: g.WIRE_TYPES.VARINT }, uint32: { name: "uint32", wireType: g.WIRE_TYPES.VARINT }, sint32: { name: "sint32", wireType: g.WIRE_TYPES.VARINT }, int64: { name: "int64", wireType: g.WIRE_TYPES.VARINT },
            uint64: { name: "uint64", wireType: g.WIRE_TYPES.VARINT }, sint64: { name: "sint64", wireType: g.WIRE_TYPES.VARINT }, bool: { name: "bool", wireType: g.WIRE_TYPES.VARINT }, "double": { name: "double", wireType: g.WIRE_TYPES.BITS64 }, string: { name: "string", wireType: g.WIRE_TYPES.LDELIM }, bytes: { name: "bytes", wireType: g.WIRE_TYPES.LDELIM }, fixed32: { name: "fixed32", wireType: g.WIRE_TYPES.BITS32 }, sfixed32: { name: "sfixed32", wireType: g.WIRE_TYPES.BITS32 }, fixed64: { name: "fixed64", wireType: g.WIRE_TYPES.BITS64 }, sfixed64: { name: "sfixed64", wireType: g.WIRE_TYPES.BITS64 },
            "float": { name: "float", wireType: g.WIRE_TYPES.BITS32 }, "enum": { name: "enum", wireType: g.WIRE_TYPES.VARINT }, message: { name: "message", wireType: g.WIRE_TYPES.LDELIM }
        }; g.Long = m.Long; g.convertFieldsToCamelCase = !1; g.Util = function () {
            Object.create || (Object.create = function (b) { function f() { } if (1 < arguments.length) throw Error("Object.create implementation only accepts the first parameter."); f.prototype = b; return new f }); var d = { IS_NODE: !1 }; try {
                d.IS_NODE = "function" === typeof require && "function" === typeof require("fs").readFileSync &&
                "function" === typeof require("path").join
            } catch (b) { } d.XHR = function () { for (var b = [function () { return new XMLHttpRequest }, function () { return new ActiveXObject("Msxml2.XMLHTTP") }, function () { return new ActiveXObject("Msxml3.XMLHTTP") }, function () { return new ActiveXObject("Microsoft.XMLHTTP") }], f = null, a = 0; a < b.length; a++) { try { f = b[a]() } catch (c) { continue } break } if (!f) throw Error("XMLHttpRequest is not supported"); return f }; d.fetch = function (b, f) {
                f && "function" != typeof f && (f = null); if (d.IS_NODE) if (f) require("fs").readFile(b,
                function (a, c) { a ? f(null) : f("" + c) }); else try { return require("fs").readFileSync(b) } catch (a) { return null } else {
                    var c = d.XHR(); c.open("GET", b, f ? !0 : !1); c.setRequestHeader("Accept", "text/plain"); "function" === typeof c.overrideMimeType && c.overrideMimeType("text/plain"); if (f) c.onreadystatechange = function () { 4 == c.readyState && (200 == c.status || 0 == c.status && "string" === typeof c.responseText ? f(c.responseText) : f(null)) }, 4 != c.readyState && c.send(null); else return c.send(null), 200 == c.status || 0 == c.status && "string" === typeof c.responseText ?
                    c.responseText : null
                }
            }; d.isArray = function (b) { return b ? b instanceof Array ? !0 : Array.isArray ? Array.isArray(b) : "[object Array]" === Object.prototype.toString.call(b) : !1 }; return d
        }(); g.Lang = {
            OPEN: "{", CLOSE: "}", OPTOPEN: "[", OPTCLOSE: "]", OPTEND: ",", EQUAL: "=", END: ";", STRINGOPEN: '"', STRINGCLOSE: '"', STRINGOPEN_SQ: "'", STRINGCLOSE_SQ: "'", COPTOPEN: "(", COPTCLOSE: ")", DELIM: /[\s\{\}=;\[\],'"\(\)]/g, KEYWORD: /^(?:package|option|import|message|enum|extend|service|syntax|extensions)$/, RULE: /^(?:required|optional|repeated)$/,
            TYPE: /^(?:double|float|int32|uint32|sint32|int64|uint64|sint64|fixed32|sfixed32|fixed64|sfixed64|bool|string|bytes)$/, NAME: /^[a-zA-Z_][a-zA-Z_0-9]*$/, OPTNAME: /^(?:[a-zA-Z][a-zA-Z_0-9]*|\([a-zA-Z][a-zA-Z_0-9]*\))$/, TYPEDEF: /^[a-zA-Z][a-zA-Z_0-9]*$/, TYPEREF: /^(?:\.?[a-zA-Z][a-zA-Z_0-9]*)+$/, FQTYPEREF: /^(?:\.[a-zA-Z][a-zA-Z_0-9]*)+$/, NUMBER: /^-?(?:[1-9][0-9]*|0|0x[0-9a-fA-F]+|0[0-7]+|([0-9]*\.[0-9]+([Ee][+-]?[0-9]+)?))$/, NUMBER_DEC: /^(?:[1-9][0-9]*|0)$/, NUMBER_HEX: /^0x[0-9a-fA-F]+$/, NUMBER_OCT: /^0[0-7]+$/,
            NUMBER_FLT: /^[0-9]*\.[0-9]+([Ee][+-]?[0-9]+)?$/, ID: /^(?:[1-9][0-9]*|0|0x[0-9a-fA-F]+|0[0-7]+)$/, NEGID: /^\-?(?:[1-9][0-9]*|0|0x[0-9a-fA-F]+|0[0-7]+)$/, WHITESPACE: /\s/, STRING: /['"]([^'"\\]*(\\.[^"\\]*)*)['"]/g, BOOL: /^(?:true|false)$/i, ID_MIN: 1, ID_MAX: 536870911
        }; g.DotProto = {}; g.DotProto.Tokenizer = function (d) {
            var b = function (b) { this.source = "" + b; this.index = 0; this.line = 1; this.stack = []; this.readingString = !1; this.stringEndsWith = d.STRINGCLOSE }; b.prototype._readString = function () {
                d.STRING.lastIndex = this.index -
                1; var b; if (null !== (b = d.STRING.exec(this.source))) return b = b[1], this.index = d.STRING.lastIndex, this.stack.push(this.stringEndsWith), b; throw Error("Illegal string value at line " + this.line + ", index " + this.index);
            }; b.prototype.next = function () {
                if (0 < this.stack.length) return this.stack.shift(); if (this.index >= this.source.length) return null; if (this.readingString) return this.readingString = !1, this._readString(); var b, f; do {
                    for (b = !1; d.WHITESPACE.test(f = this.source.charAt(this.index)) ;) if (this.index++, "\n" === f &&
                    this.line++, this.index === this.source.length) return null; if ("/" === this.source.charAt(this.index)) if ("/" === this.source.charAt(++this.index)) { for (; "\n" !== this.source.charAt(this.index) ;) if (this.index++, this.index == this.source.length) return null; this.index++; this.line++; b = !0 } else if ("*" === this.source.charAt(this.index)) { for (f = ""; "*/" !== f + (f = this.source.charAt(this.index)) ;) if (this.index++, "\n" === f && this.line++, this.index === this.source.length) return null; this.index++; b = !0 } else throw Error("Invalid comment at line " +
                    this.line + ": /" + this.source.charAt(this.index) + " ('/' or '*' expected)");
                } while (b); if (this.index === this.source.length) return null; b = this.index; d.DELIM.lastIndex = 0; if (d.DELIM.test(this.source.charAt(b))) b++; else for (b++; b < this.source.length && !d.DELIM.test(this.source.charAt(b)) ;) b++; b = this.source.substring(this.index, this.index = b); b === d.STRINGOPEN ? (this.readingString = !0, this.stringEndsWith = d.STRINGCLOSE) : b === d.STRINGOPEN_SQ && (this.readingString = !0, this.stringEndsWith = d.STRINGCLOSE_SQ); return b
            }; b.prototype.peek =
            function () { if (0 === this.stack.length) { var b = this.next(); if (null === b) return null; this.stack.push(b) } return this.stack[0] }; b.prototype.toString = function () { return "Tokenizer(" + this.index + "/" + this.source.length + " at line " + this.line + ")" }; return b
        }(g.Lang); g.DotProto.Parser = function (d, b, g) {
            d = function (b) { this.tn = new g(b) }; d.prototype.parse = function () {
                var b = { name: "[ROOT]", "package": null, messages: [], enums: [], imports: [], options: {}, services: [] }, a, c = !0; do {
                    a = this.tn.next(); if (null == a) break; if ("package" == a) {
                        if (!c) throw Error("Illegal package definition at line " +
                        this.tn.line + ": Must be declared before the first message or enum"); if (null !== b["package"]) throw Error("Illegal package definition at line " + this.tn.line + ": Package already declared"); b["package"] = this._parsePackage(a)
                    } else if ("import" == a) { if (!c) throw Error("Illegal import definition at line " + this.tn.line + ": Must be declared before the first message or enum"); b.imports.push(this._parseImport(a)) } else if ("message" === a) this._parseMessage(b, a), c = !1; else if ("enum" === a) this._parseEnum(b, a), c = !1; else if ("option" ===
                    a) { if (!c) throw Error("Illegal option definition at line " + this.tn.line + ": Must be declared before the first message or enum"); this._parseOption(b, a) } else if ("service" === a) this._parseService(b, a); else if ("extend" === a) this._parseExtend(b, a); else if ("syntax" === a) this._parseIgnoredStatement(b, a); else throw Error("Illegal top level declaration at line " + this.tn.line + ": " + a);
                } while (1); delete b.name; return b
            }; d.prototype._parseNumber = function (f) {
                var a = 1; "-" == f.charAt(0) && (a = -1, f = f.substring(1)); if (b.NUMBER_DEC.test(f)) return a *
                parseInt(f, 10); if (b.NUMBER_HEX.test(f)) return a * parseInt(f.substring(2), 16); if (b.NUMBER_OCT.test(f)) return a * parseInt(f.substring(1), 8); if (b.NUMBER_FLT.test(f)) return a * parseFloat(f); throw Error("Illegal number value at line " + this.tn.line + ": " + (0 > a ? "-" : "") + f);
            }; d.prototype._parseId = function (f, a) {
                var c = -1, d = 1; "-" == f.charAt(0) && (d = -1, f = f.substring(1)); if (b.NUMBER_DEC.test(f)) c = parseInt(f); else if (b.NUMBER_HEX.test(f)) c = parseInt(f.substring(2), 16); else if (b.NUMBER_OCT.test(f)) c = parseInt(f.substring(1),
                8); else throw Error("Illegal ID value at line " + this.tn.line + ": " + (0 > d ? "-" : "") + f); c = d * c | 0; if (!a && 0 > c) throw Error("Illegal ID range at line " + this.tn.line + ": " + (0 > d ? "-" : "") + f); return c
            }; d.prototype._parsePackage = function (f) { f = this.tn.next(); if (!b.TYPEREF.test(f)) throw Error("Illegal package name at line " + this.tn.line + ": " + f); var a = f; f = this.tn.next(); if (f != b.END) throw Error("Illegal end of package definition at line " + this.tn.line + ": " + f + " ('" + b.END + "' expected)"); return a }; d.prototype._parseImport =
            function (f) {
                f = this.tn.next(); "public" === f && (f = this.tn.next()); if (f !== b.STRINGOPEN && f !== b.STRINGOPEN_SQ) throw Error("Illegal begin of import value at line " + this.tn.line + ": " + f + " ('" + b.STRINGOPEN + "' or '" + b.STRINGOPEN_SQ + "' expected)"); var a = this.tn.next(); f = this.tn.next(); if (f !== this.tn.stringEndsWith) throw Error("Illegal end of import value at line " + this.tn.line + ": " + f + " ('" + this.tn.stringEndsWith + "' expected)"); f = this.tn.next(); if (f !== b.END) throw Error("Illegal end of import definition at line " +
                this.tn.line + ": " + f + " ('" + b.END + "' expected)"); return a
            }; d.prototype._parseOption = function (f, a) {
                a = this.tn.next(); var c = !1; a == b.COPTOPEN && (c = !0, a = this.tn.next()); if (!b.TYPEREF.test(a) && !/google\.protobuf\./.test(a)) throw Error("Illegal option name in message " + f.name + " at line " + this.tn.line + ": " + a); var d = a; a = this.tn.next(); if (c) {
                    if (a !== b.COPTCLOSE) throw Error("Illegal custom option name delimiter in message " + f.name + ", option " + d + " at line " + this.tn.line + ": " + a + " ('" + b.COPTCLOSE + "' expected)"); d =
                    "(" + d + ")"; a = this.tn.next(); b.FQTYPEREF.test(a) && (d += a, a = this.tn.next())
                } if (a !== b.EQUAL) throw Error("Illegal option operator in message " + f.name + ", option " + d + " at line " + this.tn.line + ": " + a + " ('" + b.EQUAL + "' expected)"); a = this.tn.next(); if (a === b.STRINGOPEN || a === b.STRINGOPEN_SQ) { if (c = this.tn.next(), a = this.tn.next(), a !== this.tn.stringEndsWith) throw Error("Illegal end of option value in message " + f.name + ", option " + d + " at line " + this.tn.line + ": " + a + " ('" + this.tn.stringEndsWith + "' expected)"); } else if (b.NUMBER.test(a)) c =
                this._parseNumber(a, !0); else if (b.TYPEREF.test(a)) c = a; else throw Error("Illegal option value in message " + f.name + ", option " + d + " at line " + this.tn.line + ": " + a); a = this.tn.next(); if (a !== b.END) throw Error("Illegal end of option in message " + f.name + ", option " + d + " at line " + this.tn.line + ": " + a + " ('" + b.END + "' expected)"); f.options[d] = c
            }; d.prototype._parseIgnoredBlock = function (d, a) {
                var c = this.tn.next(); if (!b.TYPEREF.test(c)) throw Error("Illegal " + a + " type in " + d.name + ": " + c); var e = c, c = this.tn.next(); if (c !==
                b.OPEN) throw Error("Illegal OPEN in " + d.name + " after " + a + " " + e + " at line " + this.tn.line + ": " + c); var h = 1; do { c = this.tn.next(); if (null === c) throw Error("Unexpected EOF in " + d.name + ", " + a + " (ignored) at line " + this.tn.line + ": " + e); if (c === b.OPEN) h++; else if (c === b.CLOSE && (c = this.tn.peek(), c === b.END && this.tn.next(), h--, 0 === h)) break } while (1)
            }; d.prototype._parseIgnoredStatement = function (d, a) {
                var c; do {
                    c = this.tn.next(); if (null === c) throw Error("Unexpected EOF in " + d.name + ", " + a + " (ignored) at line " + this.tn.line);
                    if (c === b.END) break
                } while (1)
            }; d.prototype._parseService = function (d, a) {
                var c = this.tn.next(); if (!b.NAME.test(c)) throw Error("Illegal service name at line " + this.tn.line + ": " + c); var e = c, h = { name: e, rpc: {}, options: {} }, c = this.tn.next(); if (c !== b.OPEN) throw Error("Illegal OPEN after service " + e + " at line " + this.tn.line + ": " + c + " ('" + b.OPEN + "' expected)"); do if (c = this.tn.next(), "option" === c) this._parseOption(h, c); else if ("rpc" === c) this._parseServiceRPC(h, c); else if (c !== b.CLOSE) throw Error("Illegal type for service " +
                e + " at line " + this.tn.line + ": " + c); while (c !== b.CLOSE); d.services.push(h)
            }; d.prototype._parseServiceRPC = function (d, a) {
                var c = a; a = this.tn.next(); if (!b.NAME.test(a)) throw Error("Illegal RPC method name in service " + d.name + " at line " + this.tn.line + ": " + a); var e = a, h = { request: null, response: null, options: {} }; a = this.tn.next(); if (a !== b.COPTOPEN) throw Error("Illegal start of request type in RPC service " + d.name + "#" + e + " at line " + this.tn.line + ": " + a + " ('" + b.COPTOPEN + "' expected)"); a = this.tn.next(); if (!b.TYPEREF.test(a)) throw Error("Illegal request type in RPC service " +
                d.name + "#" + e + " at line " + this.tn.line + ": " + a); h.request = a; a = this.tn.next(); if (a != b.COPTCLOSE) throw Error("Illegal end of request type in RPC service " + d.name + "#" + e + " at line " + this.tn.line + ": " + a + " ('" + b.COPTCLOSE + "' expected)"); a = this.tn.next(); if ("returns" !== a.toLowerCase()) throw Error("Illegal request/response delimiter in RPC service " + d.name + "#" + e + " at line " + this.tn.line + ": " + a + " ('returns' expected)"); a = this.tn.next(); if (a != b.COPTOPEN) throw Error("Illegal start of response type in RPC service " +
                d.name + "#" + e + " at line " + this.tn.line + ": " + a + " ('" + b.COPTOPEN + "' expected)"); a = this.tn.next(); h.response = a; a = this.tn.next(); if (a !== b.COPTCLOSE) throw Error("Illegal end of response type in RPC service " + d.name + "#" + e + " at line " + this.tn.line + ": " + a + " ('" + b.COPTCLOSE + "' expected)"); a = this.tn.next(); if (a === b.OPEN) {
                    do if (a = this.tn.next(), "option" === a) this._parseOption(h, a); else if (a !== b.CLOSE) throw Error("Illegal start of option in RPC service " + d.name + "#" + e + " at line " + this.tn.line + ": " + a + " ('option' expected)");
                    while (a !== b.CLOSE); this.tn.peek() === b.END && this.tn.next()
                } else if (a !== b.END) throw Error("Illegal method delimiter in RPC service " + d.name + "#" + e + " at line " + this.tn.line + ": " + a + " ('" + b.END + "' or '" + b.OPEN + "' expected)"); "undefined" === typeof d[c] && (d[c] = {}); d[c][e] = h
            }; d.prototype._parseMessage = function (d, a) {
                var c = {}; a = this.tn.next(); if (!b.NAME.test(a)) throw Error("Illegal message name" + (d ? " in message " + d.name : "") + " at line " + this.tn.line + ": " + a); c.name = a; a = this.tn.next(); if (a != b.OPEN) throw Error("Illegal OPEN after message " +
                c.name + " at line " + this.tn.line + ": " + a + " ('" + b.OPEN + "' expected)"); c.fields = []; c.enums = []; c.messages = []; c.options = {}; do if (a = this.tn.next(), a === b.CLOSE) { a = this.tn.peek(); a === b.END && this.tn.next(); break } else if (b.RULE.test(a)) this._parseMessageField(c, a); else if ("enum" === a) this._parseEnum(c, a); else if ("message" === a) this._parseMessage(c, a); else if ("option" === a) this._parseOption(c, a); else if ("extensions" === a) c.extensions = this._parseExtensions(c, a); else if ("extend" === a) this._parseExtend(c, a); else throw Error("Illegal token in message " +
                c.name + " at line " + this.tn.line + ": " + a + " (type or '" + b.CLOSE + "' expected)"); while (1); d.messages.push(c); return c
            }; d.prototype._parseMessageField = function (d, a) {
                var c = {}; c.rule = a; a = this.tn.next(); if (!b.TYPE.test(a) && !b.TYPEREF.test(a)) throw Error("Illegal field type in message " + d.name + " at line " + this.tn.line + ": " + a); c.type = a; a = this.tn.next(); if (!b.NAME.test(a)) throw Error("Illegal field name in message " + d.name + " at line " + this.tn.line + ": " + a); c.name = a; a = this.tn.next(); if (a !== b.EQUAL) throw Error("Illegal field number operator in message " +
                d.name + "#" + c.name + " at line " + this.tn.line + ": " + a + " ('" + b.EQUAL + "' expected)"); a = this.tn.next(); try { c.id = this._parseId(a) } catch (e) { throw Error("Illegal field id in message " + d.name + "#" + c.name + " at line " + this.tn.line + ": " + a); } c.options = {}; a = this.tn.next(); a === b.OPTOPEN && (this._parseFieldOptions(d, c, a), a = this.tn.next()); if (a !== b.END) throw Error("Illegal field delimiter in message " + d.name + "#" + c.name + " at line " + this.tn.line + ": " + a + " ('" + b.END + "' expected)"); d.fields.push(c)
            }; d.prototype._parseFieldOptions =
            function (d, a, c) { var e = !0; do { c = this.tn.next(); if (c === b.OPTCLOSE) break; else if (c === b.OPTEND) { if (e) throw Error("Illegal start of message field options in message " + d.name + "#" + a.name + " at line " + this.tn.line + ": " + c); c = this.tn.next() } this._parseFieldOption(d, a, c); e = !1 } while (1) }; d.prototype._parseFieldOption = function (d, a, c) {
                var e = !1; c === b.COPTOPEN && (c = this.tn.next(), e = !0); if (!b.NAME.test(c)) throw Error("Illegal field option in message " + d.name + "#" + a.name + " at line " + this.tn.line + ": " + c); var h = c; c = this.tn.next();
                if (e) { if (c !== b.COPTCLOSE) throw Error("Illegal custom field option name delimiter in message " + d.name + "#" + a.name + " at line " + this.tn.line + ": " + c + " (')' expected)"); h = "(" + h + ")"; c = this.tn.next(); b.FQTYPEREF.test(c) && (h += c, c = this.tn.next()) } if (c !== b.EQUAL) throw Error("Illegal field option operation in message " + d.name + "#" + a.name + " at line " + this.tn.line + ": " + c + " ('=' expected)"); c = this.tn.next(); if (c === b.STRINGOPEN || c === b.STRINGOPEN_SQ) {
                    if (e = this.tn.next(), c = this.tn.next(), c != this.tn.stringEndsWith) throw Error("Illegal end of field value in message " +
                    d.name + "#" + a.name + ", option " + h + " at line " + this.tn.line + ": " + c + " ('" + this.tn.stringEndsWith + "' expected)");
                } else if (b.NUMBER.test(c, !0)) e = this._parseNumber(c, !0); else if (b.BOOL.test(c)) e = "true" === c.toLowerCase(); else if (b.TYPEREF.test(c)) e = c; else throw Error("Illegal field option value in message " + d.name + "#" + a.name + ", option " + h + " at line " + this.tn.line + ": " + c); a.options[h] = e
            }; d.prototype._parseEnum = function (d, a) {
                var c = {}; a = this.tn.next(); if (!b.NAME.test(a)) throw Error("Illegal enum name in message " +
                d.name + " at line " + this.tn.line + ": " + a); c.name = a; a = this.tn.next(); if (a !== b.OPEN) throw Error("Illegal OPEN after enum " + c.name + " at line " + this.tn.line + ": " + a); c.values = []; c.options = {}; do { a = this.tn.next(); if (a === b.CLOSE) { a = this.tn.peek(); a === b.END && this.tn.next(); break } if ("option" == a) this._parseOption(c, a); else { if (!b.NAME.test(a)) throw Error("Illegal enum value name in enum " + c.name + " at line " + this.tn.line + ": " + a); this._parseEnumValue(c, a) } } while (1); d.enums.push(c)
            }; d.prototype._parseEnumValue = function (d,
            a) {
                var c = {}; c.name = a; a = this.tn.next(); if (a !== b.EQUAL) throw Error("Illegal enum value operator in enum " + d.name + " at line " + this.tn.line + ": " + a + " ('" + b.EQUAL + "' expected)"); a = this.tn.next(); try { c.id = this._parseId(a, !0) } catch (e) { throw Error("Illegal enum value id in enum " + d.name + " at line " + this.tn.line + ": " + a); } d.values.push(c); a = this.tn.next(); a === b.OPTOPEN && (this._parseFieldOptions(d, { options: {} }, a), a = this.tn.next()); if (a !== b.END) throw Error("Illegal enum value delimiter in enum " + d.name + " at line " +
                this.tn.line + ": " + a + " ('" + b.END + "' expected)");
            }; d.prototype._parseExtensions = function (d, a) {
                var c = []; a = this.tn.next(); "min" === a ? c.push(b.ID_MIN) : "max" === a ? c.push(b.ID_MAX) : c.push(this._parseNumber(a)); a = this.tn.next(); if ("to" !== a) throw "Illegal extensions delimiter in message " + d.name + " at line " + this.tn.line + " ('to' expected)"; a = this.tn.next(); "min" === a ? c.push(b.ID_MIN) : "max" === a ? c.push(b.ID_MAX) : c.push(this._parseNumber(a)); a = this.tn.next(); if (a !== b.END) throw Error("Illegal extension delimiter in message " +
                d.name + " at line " + this.tn.line + ": " + a + " ('" + b.END + "' expected)"); return c
            }; d.prototype._parseExtend = function (d, a) {
                a = this.tn.next(); if (!b.TYPEREF.test(a)) throw Error("Illegal extended message name at line " + this.tn.line + ": " + a); var c = {}; c.ref = a; c.fields = []; a = this.tn.next(); if (a !== b.OPEN) throw Error("Illegal OPEN in extend " + c.name + " at line " + this.tn.line + ": " + a + " ('" + b.OPEN + "' expected)"); do if (a = this.tn.next(), a === b.CLOSE) { a = this.tn.peek(); a == b.END && this.tn.next(); break } else if (b.RULE.test(a)) this._parseMessageField(c,
                a); else throw Error("Illegal token in extend " + c.name + " at line " + this.tn.line + ": " + a + " (rule or '" + b.CLOSE + "' expected)"); while (1); d.messages.push(c); return c
            }; d.prototype.toString = function () { return "Parser" }; return d
        }(g, g.Lang, g.DotProto.Tokenizer); g.Reflect = function (d) {
            function b(a, c) {
                if (a && "number" === typeof a.low && "number" === typeof a.high && "boolean" === typeof a.unsigned) return new d.Long(a.low, a.high, "undefined" === typeof c ? a.unsigned : c); if ("string" === typeof a) return d.Long.fromString(a, c || !1, 10);
                if ("number" === typeof a) return d.Long.fromNumber(a, c || !1); throw Error("not convertible to Long");
            } var g = {}, f = function (a, c) { this.parent = a; this.name = c }; f.prototype.fqn = function () { var a = this.name, c = this; do { c = c.parent; if (null == c) break; a = c.name + "." + a } while (1); return a }; f.prototype.toString = function (d) {
                var b = this.fqn(); d && (this instanceof c ? b = "Message " + b : this instanceof c.Field ? b = "Message.Field " + b : this instanceof h ? b = "Enum " + b : this instanceof h.Value ? b = "Enum.Value " + b : this instanceof n ? b = "Service " + b :
                this instanceof n.Method ? b = this instanceof n.RPCMethod ? "Service.RPCMethod " + b : "Service.Method " + b : this instanceof a && (b = "Namespace " + b)); return b
            }; f.prototype.build = function () { throw Error(this.toString(!0) + " cannot be built directly"); }; g.T = f; var a = function (a, c, b) { f.call(this, a, c); this.children = []; this.options = b || {} }; a.prototype = Object.create(f.prototype); a.prototype.getChildren = function (a) {
                a = a || null; if (null == a) return this.children.slice(); for (var c = [], b = 0; b < this.children.length; b++) this.children[b] instanceof
                a && c.push(this.children[b]); return c
            }; a.prototype.addChild = function (a) { var b; if (b = this.getChild(a.name)) if (b instanceof c.Field && b.name !== b.originalName && !this.hasChild(b.originalName)) b.name = b.originalName; else if (a instanceof c.Field && a.name !== a.originalName && !this.hasChild(a.originalName)) a.name = a.originalName; else throw Error("Duplicate name in namespace " + this.toString(!0) + ": " + a.name); this.children.push(a) }; a.prototype.hasChild = function (a) {
                var c; if ("number" == typeof a) for (c = 0; c < this.children.length; c++) {
                    if ("undefined" !==
                    typeof this.children[c].id && this.children[c].id == a) return !0
                } else for (c = 0; c < this.children.length; c++) if ("undefined" !== typeof this.children[c].name && this.children[c].name == a) return !0; return !1
            }; a.prototype.getChild = function (a) {
                var c; if ("number" == typeof a) for (c = 0; c < this.children.length; c++) { if ("undefined" !== typeof this.children[c].id && this.children[c].id == a) return this.children[c] } else for (c = 0; c < this.children.length; c++) if ("undefined" !== typeof this.children[c].name && this.children[c].name == a) return this.children[c];
                return null
            }; a.prototype.resolve = function (a, c) { var b = a.split("."), d = this, e = 0; if ("" == b[e]) { for (; null != d.parent;) d = d.parent; e++ } do { do { d = d.getChild(b[e]); if (!(d && d instanceof g.T) || c && d instanceof g.Message.Field) { d = null; break } e++ } while (e < b.length); if (null != d) break; if (null !== this.parent) return this.parent.resolve(a, c) } while (null != d); return d }; a.prototype.build = function () {
                for (var c = {}, b = this.getChildren(), d, e = 0; e < b.length; e++) d = b[e], d instanceof a && (c[d.name] = d.build()); Object.defineProperty && Object.defineProperty(c,
                "$options", { value: this.buildOpt(), enumerable: !1, configurable: !1, writable: !1 }); return c
            }; a.prototype.buildOpt = function () { for (var a = {}, c = Object.keys(this.options), b = 0; b < c.length; b++) a[c[b]] = this.options[c[b]]; return a }; a.prototype.getOption = function (a) { return "undefined" == typeof a ? this.options : "undefined" != typeof this.options[a] ? this.options[a] : null }; g.Namespace = a; var c = function (c, b, e) { a.call(this, c, b, e); this.extensions = [d.Lang.ID_MIN, d.Lang.ID_MAX]; this.clazz = null }; c.prototype = Object.create(a.prototype);
            c.prototype.build = function (a) {
                if (this.clazz && !a) return this.clazz; a = function (a, c) {
                    function b(a, c) { var d = {}, e; for (e in a) a.hasOwnProperty(e) && (null === a[e] || "object" !== typeof a[e] ? d[e] = a[e] : a[e] instanceof m ? c && (d[e] = a.toBuffer()) : d[e] = b(a[e], c)); return d } var d = c.getChildren(g.Message.Field), e = function (c) {
                        a.Builder.Message.call(this); var b, e; for (b = 0; b < d.length; b++) e = d[b], this[e.name] = e.repeated ? [] : null; for (b = 0; b < d.length; b++) if (e = d[b], "undefined" != typeof e.options["default"]) try { this.$set(e.name, e.options["default"]) } catch (l) {
                            throw Error("[INTERNAL] " +
                            l);
                        } if (1 != arguments.length || "object" != typeof c || "function" == typeof c.encode || a.Util.isArray(c) || c instanceof m || c instanceof ArrayBuffer || a.Long && c instanceof a.Long) for (b = 0; b < arguments.length; b++) b < d.length && this.$set(d[b].name, arguments[b]); else for (e = Object.keys(c), b = 0; b < e.length; b++) this.$set(e[b], c[e[b]])
                    }; e.prototype = Object.create(a.Builder.Message.prototype); e.prototype.add = function (b, d, e) {
                        var l = c.getChild(b); if (!l) throw Error(this + "#" + b + " is undefined"); if (!(l instanceof a.Reflect.Message.Field)) throw Error(this +
                        "#" + b + " is not a field: " + l.toString(!0)); if (!l.repeated) throw Error(this + "#" + b + " is not a repeated field"); null === this[l.name] && (this[l.name] = []); this[l.name].push(e ? d : l.verifyValue(d, !0))
                    }; e.prototype.$add = e.prototype.add; e.prototype.set = function (b, d, e) { var l = c.getChild(b); if (!l) throw Error(this + "#" + b + " is not a field: undefined"); if (!(l instanceof a.Reflect.Message.Field)) throw Error(this + "#" + b + " is not a field: " + l.toString(!0)); this[l.name] = e ? d : l.verifyValue(d) }; e.prototype.$set = e.prototype.set;
                    e.prototype.get = function (b) { var d = c.getChild(b); if (!(d && d instanceof a.Reflect.Message.Field)) throw Error(this + "#" + b + " is not a field: undefined"); if (!(d instanceof a.Reflect.Message.Field)) throw Error(this + "#" + b + " is not a field: " + d.toString(!0)); return this[d.name] }; e.prototype.$get = e.prototype.get; for (var l = 0; l < d.length; l++) (function (a) {
                        var b = a.originalName.replace(/(_[a-zA-Z])/g, function (a) { return a.toUpperCase().replace("_", "") }), b = b.substring(0, 1).toUpperCase() + b.substring(1), d = a.originalName.replace(/([A-Z])/g,
                        function (a) { return "_" + a }); c.hasChild("set" + b) || (e.prototype["set" + b] = function (c) { this.$set(a.name, c) }); c.hasChild("set_" + d) || (e.prototype["set_" + d] = function (c) { this.$set(a.name, c) }); c.hasChild("get" + b) || (e.prototype["get" + b] = function () { return this.$get(a.name) }); c.hasChild("get_" + d) || (e.prototype["get_" + d] = function () { return this.$get(a.name) })
                    })(d[l]); e.prototype.encode = function (a) {
                        var b = !1; a || (a = new m, b = !0); var d = a.littleEndian; try { return c.encode(this, a.LE()), (b ? a.flip() : a).LE(d) } catch (e) {
                            throw a.LE(d),
                            e;
                        }
                    }; e.prototype.encodeDelimited = function (a) { var b = !1; a || (a = new m, b = !0); try { var d = (new m).LE(); c.encode(this, d).flip(); a.writeVarint32(d.remaining()); a.append(d); return b ? a.flip() : a } catch (e) { throw e; } }; e.prototype.encodeAB = function () { try { return this.encode().toArrayBuffer() } catch (a) { throw a.encoded && (a.encoded = a.encoded.toArrayBuffer()), a; } }; e.prototype.toArrayBuffer = e.prototype.encodeAB; e.prototype.encodeNB = function () {
                        try { return this.encode().toBuffer() } catch (a) {
                            throw a.encoded && (a.encoded = a.encoded.toBuffer()),
                            a;
                        }
                    }; e.prototype.toBuffer = e.prototype.encodeNB; e.prototype.encode64 = function () { try { return this.encode().toBase64() } catch (a) { throw a.encoded && (a.encoded = a.encoded.toBase64()), a; } }; e.prototype.toBase64 = e.prototype.encode64; e.prototype.encodeHex = function () { try { return this.encode().toHex() } catch (a) { throw a.encoded && (a.encoded = a.encoded.toHex()), a; } }; e.prototype.toHex = e.prototype.encodeHex; e.prototype.toRaw = function (a) { return b(this, !!a) }; e.decode = function (a, b) {
                        if (null === a) throw Error("buffer must not be null");
                        "string" === typeof a && (a = m.wrap(a, b ? b : "base64")); a = a instanceof m ? a : m.wrap(a); var d = a.littleEndian; try { var e = c.decode(a.LE()); a.LE(d); return e } catch (l) { throw a.LE(d), l; }
                    }; e.decodeDelimited = function (a, b) { if (null === a) throw Error("buffer must not be null"); "string" === typeof a && (a = m.wrap(a, b ? b : "base64")); a = a instanceof m ? a : m.wrap(a); var d = a.readVarint32(), e = c.decode(a.slice(a.offset, a.offset + d).LE()); a.offset += d; return e }; e.decode64 = function (a) { return e.decode(a, "base64") }; e.decodeHex = function (a) {
                        return e.decode(a,
                        "hex")
                    }; e.prototype.toString = function () { return c.toString() }; Object.defineProperty && Object.defineProperty(e, "$options", { value: c.buildOpt(), enumerable: !1, configurable: !1, writable: !1 }); return e
                }(d, this); for (var b = this.getChildren(), e = 0; e < b.length; e++) if (b[e] instanceof h) a[b[e].name] = b[e].build(); else if (b[e] instanceof c) a[b[e].name] = b[e].build(); else if (!(b[e] instanceof c.Field)) throw Error("Illegal reflect child of " + this.toString(!0) + ": " + b[e].toString(!0)); return this.clazz = a
            }; c.prototype.encode =
            function (a, b) { for (var d = this.getChildren(c.Field), e = null, f = 0; f < d.length; f++) { var h = a.$get(d[f].name); d[f].required && null === h ? null === e && (e = d[f]) : d[f].encode(h, b) } if (null !== e) throw d = Error("Missing at least one required field for " + this.toString(!0) + ": " + e), d.encoded = b, d; return b }; c.prototype.encodeDelimitied = function (a, b) { var c = new m; this.encode(a, c); c.flip(); b.writeVarint32(c.remaining()); b.append(c); return b }; c.prototype.decode = function (a, b) {
                b = "number" === typeof b ? b : -1; for (var c = a.offset, e = new this.clazz; a.offset <
                c + b || -1 == b && 0 < a.remaining() ;) { var f = a.readVarint32(), h = f & 7, f = f >> 3, g = this.getChild(f); if (g) g.repeated && !g.options.packed ? e.$add(g.name, g.decode(h, a), !0) : e.$set(g.name, g.decode(h, a), !0); else switch (h) { case d.WIRE_TYPES.VARINT: a.readVarint32(); break; case d.WIRE_TYPES.BITS32: a.offset += 4; break; case d.WIRE_TYPES.BITS64: a.offset += 8; break; case d.WIRE_TYPES.LDELIM: h = a.readVarint32(); a.offset += h; break; default: throw Error("Illegal wire type of unknown field " + f + " in " + this.toString(!0) + "#decode: " + h); } } c = this.getChildren(d.Reflect.Field);
                for (h = 0; h < c.length; h++) if (c[h].required && null === e[c[h].name]) throw c = Error("Missing at least one required field for " + this.toString(!0) + ": " + c[h].name), c.decoded = e, c; return e
            }; g.Message = c; var e = function (a, b, c, e, h, g) { f.call(this, a, e); this.required = "required" == b; this.repeated = "repeated" == b; this.type = c; this.resolvedType = null; this.id = h; this.options = g || {}; this.originalName = this.name; d.convertFieldsToCamelCase && (this.name = this.name.replace(/_([a-zA-Z])/g, function (a, b) { return b.toUpperCase() })) }; e.prototype =
            Object.create(f.prototype); e.prototype.verifyValue = function (a, c) {
                c = c || !1; if (null === a) { if (this.required) throw Error("Illegal value for " + this.toString(!0) + ": " + a + " (required)"); return null } var e; if (this.repeated && !c) { d.Util.isArray(a) || (a = [a]); var f = []; for (e = 0; e < a.length; e++) f.push(this.verifyValue(a[e], !0)); return f } if (!this.repeated && d.Util.isArray(a)) throw Error("Illegal value for " + this.toString(!0) + ": " + a + " (no array expected)"); if (this.type == d.TYPES.int32 || this.type == d.TYPES.sint32 || this.type ==
                d.TYPES.sfixed32) return isNaN(e = parseInt(a, 10)) ? e : e | 0; if (this.type == d.TYPES.uint32 || this.type == d.TYPES.fixed32) return isNaN(e = parseInt(a, 10)) ? e : e >>> 0; if (d.Long) {
                    if (this.type == d.TYPES.int64 || this.type == d.TYPES.sint64 || this.type == d.TYPES.sfixed64) try { return b(a, !1) } catch (g) { throw Error("Illegal value for " + this.toString(!0) + ": " + a + " (" + g.message + ")"); } if (this.type == d.TYPES.uint64 || this.type == d.TYPES.fixed64) try { return b(a, !0) } catch (k) {
                        throw Error("Illegal value for " + this.toString(!0) + ": " + a + " (" + k.message +
                        ")");
                    }
                } if (this.type == d.TYPES.bool) return "string" === typeof a ? "true" === a : !!a; if (this.type == d.TYPES["float"] || this.type == d.TYPES["double"]) return parseFloat(a); if (this.type == d.TYPES.string) return "" + a; if (this.type == d.TYPES.bytes) return a && a instanceof m ? a : m.wrap(a); if (this.type == d.TYPES["enum"]) { f = this.resolvedType.getChildren(h.Value); for (e = 0; e < f.length; e++) if (f[e].name == a || f[e].id == a) return f[e].id; throw Error("Illegal value for " + this.toString(!0) + ": " + a + " (not a valid enum value)"); } if (this.type ==
                d.TYPES.message) { if ("object" !== typeof a) throw Error("Illegal value for " + this.toString(!0) + ": " + a + " (object expected)"); return a instanceof this.resolvedType.clazz ? a : new this.resolvedType.clazz(a) } throw Error("[INTERNAL] Illegal value for " + this.toString(!0) + ": " + a + " (undefined type " + this.type + ")");
            }; e.prototype.encode = function (a, b) {
                a = this.verifyValue(a); if (null == this.type || "object" != typeof this.type) throw Error("[INTERNAL] Unresolved type in " + this.toString(!0) + ": " + this.type); if (null === a || this.repeated &&
                0 == a.length) return b; try {
                    if (this.repeated) { var c; if (this.options.packed) { b.writeVarint32(this.id << 3 | d.WIRE_TYPES.LDELIM); b.ensureCapacity(b.offset += 1); var e = b.offset; for (c = 0; c < a.length; c++) this.encodeValue(a[c], b); var f = b.offset - e, h = m.calculateVarint32(f); if (1 < h) { var g = b.slice(e, b.offset), e = e + (h - 1); b.offset = e; b.append(g) } b.writeVarint32(f, e - h) } else for (c = 0; c < a.length; c++) b.writeVarint32(this.id << 3 | this.type.wireType), this.encodeValue(a[c], b) } else b.writeVarint32(this.id << 3 | this.type.wireType), this.encodeValue(a,
                    b)
                } catch (k) { throw Error("Illegal value for " + this.toString(!0) + ": " + a + " (" + k + ")"); } return b
            }; e.prototype.encodeValue = function (a, b) {
                if (null !== a) {
                    if (this.type == d.TYPES.int32) 0 > a ? b.writeVarint64(a) : b.writeVarint32(a); else if (this.type == d.TYPES.uint32) b.writeVarint32(a); else if (this.type == d.TYPES.sint32) b.writeVarint32ZigZag(a); else if (this.type == d.TYPES.fixed32) b.writeUint32(a); else if (this.type == d.TYPES.sfixed32) b.writeInt32(a); else if (this.type == d.TYPES.int64 || this.type == d.TYPES.uint64) b.writeVarint64(a);
                    else if (this.type == d.TYPES.sint64) b.writeVarint64ZigZag(a); else if (this.type == d.TYPES.fixed64) b.writeUint64(a); else if (this.type == d.TYPES.sfixed64) b.writeInt64(a); else if (this.type == d.TYPES.bool) "string" === typeof a ? b.writeVarint32("false" === a.toLowerCase() ? 0 : !!a) : b.writeVarint32(a ? 1 : 0); else if (this.type == d.TYPES["enum"]) b.writeVarint32(a); else if (this.type == d.TYPES["float"]) b.writeFloat32(a); else if (this.type == d.TYPES["double"]) b.writeFloat64(a); else if (this.type == d.TYPES.string) b.writeVString(a);
                    else if (this.type == d.TYPES.bytes) a.offset > a.length && (b = b.clone().flip()), b.writeVarint32(a.remaining()), b.append(a); else if (this.type == d.TYPES.message) { var c = (new m).LE(); this.resolvedType.encode(a, c); b.writeVarint32(c.offset); b.append(c.flip()) } else throw Error("[INTERNAL] Illegal value to encode in " + this.toString(!0) + ": " + a + " (unknown type)"); return b
                }
            }; e.prototype.decode = function (a, b, c) {
                if (a != this.type.wireType && (c || a != d.WIRE_TYPES.LDELIM || !this.repeated)) throw Error("Illegal wire type for field " +
                this.toString(!0) + ": " + a + " (" + this.type.wireType + " expected)"); if (a == d.WIRE_TYPES.LDELIM && this.repeated && this.options.packed && !c) { a = b.readVarint32(); a = b.offset + a; for (c = []; b.offset < a;) c.push(this.decode(this.type.wireType, b, !0)); return c } if (this.type == d.TYPES.int32) return b.readVarint32() | 0; if (this.type == d.TYPES.uint32) return b.readVarint32() >>> 0; if (this.type == d.TYPES.sint32) return b.readVarint32ZigZag() | 0; if (this.type == d.TYPES.fixed32) return b.readUint32() >>> 0; if (this.type == d.TYPES.sfixed32) return b.readInt32() |
                0; if (this.type == d.TYPES.int64) return b.readVarint64(); if (this.type == d.TYPES.uint64) return b.readVarint64().toUnsigned(); if (this.type == d.TYPES.sint64) return b.readVarint64ZigZag(); if (this.type == d.TYPES.fixed64) return b.readUint64(); if (this.type == d.TYPES.sfixed64) return b.readInt64(); if (this.type == d.TYPES.bool) return !!b.readVarint32(); if (this.type == d.TYPES["enum"]) return b.readVarint32(); if (this.type == d.TYPES["float"]) return b.readFloat(); if (this.type == d.TYPES["double"]) return b.readDouble(); if (this.type ==
                d.TYPES.string) return b.readVString(); if (this.type == d.TYPES.bytes) { a = b.readVarint32(); if (b.remaining() < a) throw Error("Illegal number of bytes for " + this.toString(!0) + ": " + a + " required but got only " + b.remaining()); c = b.clone(); c.length = c.offset + a; b.offset += a; return c } if (this.type == d.TYPES.message) return a = b.readVarint32(), this.resolvedType.decode(b, a); throw Error("[INTERNAL] Illegal wire type for " + this.toString(!0) + ": " + a);
            }; g.Message.Field = e; var h = function (b, c, d) { a.call(this, b, c, d); this.object = null };
            h.prototype = Object.create(a.prototype); h.prototype.build = function () { for (var a = {}, b = this.getChildren(h.Value), c = 0; c < b.length; c++) a[b[c].name] = b[c].id; Object.defineProperty && Object.defineProperty(a, "$options", { value: this.buildOpt(), enumerable: !1, configurable: !1, writable: !1 }); return this.object = a }; g.Enum = h; e = function (a, b, c) { f.call(this, a, b); this.id = c }; e.prototype = Object.create(f.prototype); g.Enum.Value = e; var n = function (b, c, d) { a.call(this, b, c, d); this.clazz = null }; n.prototype = Object.create(a.prototype);
            n.prototype.build = function (a) {
                return this.clazz && !a ? this.clazz : this.clazz = function (a, b) {
                    var c = function (b) { a.Builder.Service.call(this); this.rpcImpl = b || function (a, b, c) { setTimeout(c.bind(this, Error("Not implemented, see: https://github.com/dcodeIO/ProtoBuf.js/wiki/Services")), 0) } }; c.prototype = Object.create(a.Builder.Service.prototype); Object.defineProperty && (Object.defineProperty(c, "$options", { value: b.buildOpt(), enumerable: !1, configurable: !1, writable: !1 }), Object.defineProperty(c.prototype, "$options",
                    { value: c.$options, enumerable: !1, configurable: !1, writable: !1 })); for (var d = b.getChildren(g.Service.RPCMethod), e = 0; e < d.length; e++) (function (a) {
                        c.prototype[a.name] = function (c, d) {
                            try {
                                c && c instanceof a.resolvedRequestType.clazz || setTimeout(d.bind(this, Error("Illegal request type provided to service method " + b.name + "#" + a.name))), this.rpcImpl(a.fqn(), c, function (c, e) {
                                    if (c) d(c); else {
                                        try { e = a.resolvedResponseType.clazz.decode(e) } catch (f) { } e && e instanceof a.resolvedResponseType.clazz ? d(null, e) : d(Error("Illegal response type received in service method " +
                                        b.name + "#" + a.name))
                                    }
                                })
                            } catch (e) { setTimeout(d.bind(this, e), 0) }
                        }; c[a.name] = function (b, d, e) { (new c(b))[a.name](d, e) }; Object.defineProperty && (Object.defineProperty(c[a.name], "$options", { value: a.buildOpt(), enumerable: !1, configurable: !1, writable: !1 }), Object.defineProperty(c.prototype[a.name], "$options", { value: c[a.name].$options, enumerable: !1, configurable: !1, writable: !1 }))
                    })(d[e]); return c
                }(d, this)
            }; g.Service = n; var k = function (a, b, c) { f.call(this, a, b); this.options = c || {} }; k.prototype = Object.create(f.prototype);
            k.prototype.buildOpt = a.prototype.buildOpt; g.Service.Method = k; e = function (a, b, c, d, e) { k.call(this, a, b, e); this.requestName = c; this.responseName = d; this.resolvedResponseType = this.resolvedRequestType = null }; e.prototype = Object.create(k.prototype); g.Service.RPCMethod = e; return g
        }(g); g.Builder = function (d, b, g) {
            var f = function () { this.ptr = this.ns = new g.Namespace(null, ""); this.resolved = !1; this.result = null; this.files = {}; this.importRoot = null }; f.prototype.reset = function () { this.ptr = this.ns }; f.prototype.define = function (a,
            c) { if ("string" !== typeof a || !b.TYPEREF.test(a)) throw Error("Illegal package name: " + a); var d = a.split("."), f; for (f = 0; f < d.length; f++) if (!b.NAME.test(d[f])) throw Error("Illegal package name: " + d[f]); for (f = 0; f < d.length; f++) this.ptr.hasChild(d[f]) || this.ptr.addChild(new g.Namespace(this.ptr, d[f], c)), this.ptr = this.ptr.getChild(d[f]); return this }; f.isValidMessage = function (a) {
                if ("string" !== typeof a.name || !b.NAME.test(a.name) || "undefined" !== typeof a.values || "undefined" !== typeof a.rpc) return !1; var c; if ("undefined" !==
                typeof a.fields) { if (!d.Util.isArray(a.fields)) return !1; var e = [], g; for (c = 0; c < a.fields.length; c++) { if (!f.isValidMessageField(a.fields[c])) return !1; g = parseInt(a.fields[c].id, 10); if (0 <= e.indexOf(g)) return !1; e.push(g) } } if ("undefined" !== typeof a.enums) { if (!d.Util.isArray(a.enums)) return !1; for (c = 0; c < a.enums.length; c++) if (!f.isValidEnum(a.enums[c])) return !1 } if ("undefined" !== typeof a.messages) { if (!d.Util.isArray(a.messages)) return !1; for (c = 0; c < a.messages.length; c++) if (!f.isValidMessage(a.messages[c]) && !f.isValidExtend(a.messages[c])) return !1 } return "undefined" ===
                typeof a.extensions || d.Util.isArray(a.extensions) && 2 === a.extensions.length && "number" === typeof a.extensions[0] && "number" === typeof a.extensions[1] ? !0 : !1
            }; f.isValidMessageField = function (a) {
                if ("string" !== typeof a.rule || "string" !== typeof a.name || "string" !== typeof a.type || "undefined" === typeof a.id || !(b.RULE.test(a.rule) && b.NAME.test(a.name) && b.TYPEREF.test(a.type) && b.ID.test("" + a.id))) return !1; if ("undefined" != typeof a.options) {
                    if ("object" != typeof a.options) return !1; for (var c = Object.keys(a.options), d = 0; d <
                    c.length; d++) if (!b.OPTNAME.test(c[d]) || "string" !== typeof a.options[c[d]] && "number" !== typeof a.options[c[d]] && "boolean" !== typeof a.options[c[d]]) return !1
                } return !0
            }; f.isValidEnum = function (a) {
                if ("string" !== typeof a.name || !b.NAME.test(a.name) || "undefined" === typeof a.values || !d.Util.isArray(a.values) || 0 == a.values.length) return !1; for (var c = 0; c < a.values.length; c++) if ("object" != typeof a.values[c] || "string" !== typeof a.values[c].name || "undefined" === typeof a.values[c].id || !b.NAME.test(a.values[c].name) || !b.NEGID.test("" +
                a.values[c].id)) return !1; return !0
            }; f.prototype.create = function (a) {
                if (a && (d.Util.isArray(a) || (a = [a]), 0 != a.length)) {
                    var c = [], e, h, n, k, l; for (c.push(a) ; 0 < c.length;) {
                        a = c.pop(); if (d.Util.isArray(a)) for (; 0 < a.length;) if (e = a.shift(), f.isValidMessage(e)) {
                            h = new g.Message(this.ptr, e.name, e.options); if (e.fields && 0 < e.fields.length) for (k = 0; k < e.fields.length; k++) {
                                if (h.hasChild(e.fields[k].id)) throw Error("Duplicate field id in message " + h.name + ": " + e.fields[k].id); if (e.fields[k].options) for (n = Object.keys(e.fields[k].options),
                                l = 0; l < n.length; l++) { if (!b.OPTNAME.test(n[l])) throw Error("Illegal field option name in message " + h.name + "#" + e.fields[k].name + ": " + n[l]); if ("string" !== typeof e.fields[k].options[n[l]] && "number" !== typeof e.fields[k].options[n[l]] && "boolean" !== typeof e.fields[k].options[n[l]]) throw Error("Illegal field option value in message " + h.name + "#" + e.fields[k].name + "#" + n[l] + ": " + e.fields[k].options[n[l]]); } h.addChild(new g.Message.Field(h, e.fields[k].rule, e.fields[k].type, e.fields[k].name, e.fields[k].id, e.fields[k].options))
                            } n =
                            []; if ("undefined" !== typeof e.enums && 0 < e.enums.length) for (k = 0; k < e.enums.length; k++) n.push(e.enums[k]); if (e.messages && 0 < e.messages.length) for (k = 0; k < e.messages.length; k++) n.push(e.messages[k]); e.extensions && (h.extensions = e.extensions, h.extensions[0] < d.Lang.ID_MIN && (h.extensions[0] = d.Lang.ID_MIN), h.extensions[1] > d.Lang.ID_MAX && (h.extensions[1] = d.Lang.ID_MAX)); this.ptr.addChild(h); 0 < n.length && (c.push(a), a = n, this.ptr = h)
                        } else if (f.isValidEnum(e)) {
                            h = new g.Enum(this.ptr, e.name, e.options); for (k = 0; k < e.values.length; k++) h.addChild(new g.Enum.Value(h,
                            e.values[k].name, e.values[k].id)); this.ptr.addChild(h)
                        } else if (f.isValidService(e)) { h = new g.Service(this.ptr, e.name, e.options); for (k in e.rpc) e.rpc.hasOwnProperty(k) && h.addChild(new g.Service.RPCMethod(h, k, e.rpc[k].request, e.rpc[k].response, e.rpc[k].options)); this.ptr.addChild(h) } else if (f.isValidExtend(e)) if (h = this.ptr.resolve(e.ref)) for (k = 0; k < e.fields.length; k++) {
                            if (h.hasChild(e.fields[k].id)) throw Error("Duplicate extended field id in message " + h.name + ": " + e.fields[k].id); if (e.fields[k].id < h.extensions[0] ||
                            e.fields[k].id > h.extensions[1]) throw Error("Illegal extended field id in message " + h.name + ": " + e.fields[k].id + " (" + h.extensions.join(" to ") + " expected)"); h.addChild(new g.Message.Field(h, e.fields[k].rule, e.fields[k].type, e.fields[k].name, e.fields[k].id, e.fields[k].options))
                        } else { if (!/\.?google\.protobuf\./.test(e.ref)) throw Error("Extended message " + e.ref + " is not defined"); } else throw Error("Not a valid message, enum, service or extend definition: " + JSON.stringify(e)); else throw Error("Not a valid namespace definition: " +
                        JSON.stringify(a)); this.ptr = this.ptr.parent
                    } this.resolved = !1; this.result = null; return this
                }
            }; f.isValidImport = function (a) { return !/google\/protobuf\//.test(a) }; f.prototype["import"] = function (a, b) {
                if ("string" === typeof b) { d.Util.IS_NODE && (b = require("path").resolve(b)); if (this.files[b]) return this.reset(), this; this.files[b] = !0 } if (a.imports && 0 < a.imports.length) {
                    var e, g = "/", n = !1; if ("object" === typeof b) { if (this.importRoot = b.root, n = !0, e = this.importRoot, b = b.file, 0 <= e.indexOf("\\") || 0 <= b.indexOf("\\")) g = "\\" } else "string" ===
                    typeof b ? this.importRoot ? e = this.importRoot : 0 <= b.indexOf("/") ? (e = b.replace(/\/[^\/]*$/, ""), "" === e && (e = "/")) : 0 <= b.indexOf("\\") ? (e = b.replace(/\\[^\\]*$/, ""), g = "\\") : e = "." : e = null; for (var k = 0; k < a.imports.length; k++) if ("string" === typeof a.imports[k]) {
                        if (!e) throw Error("Cannot determine import root: File name is unknown"); var l = e + g + a.imports[k]; if (f.isValidImport(l)) {
                            /\.proto$/i.test(l) && !d.DotProto && (l = l.replace(/\.proto$/, ".json")); var m = d.Util.fetch(l); if (null === m) throw Error("Failed to import '" + l +
                            "' in '" + b + "': File not found"); if (/\.json$/i.test(l)) this["import"](JSON.parse(m + ""), l); else this["import"]((new d.DotProto.Parser(m + "")).parse(), l)
                        }
                    } else if (b) if (/\.(\w+)$/.test(b)) this["import"](a.imports[k], b.replace(/^(.+)\.(\w+)$/, function (a, b, c) { return b + "_import" + k + "." + c })); else this["import"](a.imports[k], b + "_import" + k); else this["import"](a.imports[k]); n && (this.importRoot = null)
                } a.messages && (a["package"] && this.define(a["package"], a.options), this.create(a.messages), this.reset()); a.enums &&
                (a["package"] && this.define(a["package"], a.options), this.create(a.enums), this.reset()); a.services && (a["package"] && this.define(a["package"], a.options), this.create(a.services), this.reset()); a["extends"] && (a["package"] && this.define(a["package"], a.options), this.create(a["extends"]), this.reset()); return this
            }; f.isValidService = function (a) { return "string" === typeof a.name && b.NAME.test(a.name) && "object" === typeof a.rpc ? !0 : !1 }; f.isValidExtend = function (a) {
                if ("string" !== typeof a.ref || !b.TYPEREF.test(a.name)) return !1;
                var c; if ("undefined" !== typeof a.fields) { if (!d.Util.isArray(a.fields)) return !1; var e = [], g; for (c = 0; c < a.fields.length; c++) { if (!f.isValidMessageField(a.fields[c])) return !1; g = parseInt(a.id, 10); if (0 <= e.indexOf(g)) return !1; e.push(g) } } return !0
            }; f.prototype.resolveAll = function () {
                var a; if (null != this.ptr && "object" !== typeof this.ptr.type) {
                    if (this.ptr instanceof g.Namespace) { a = this.ptr.getChildren(); for (var c = 0; c < a.length; c++) this.ptr = a[c], this.resolveAll() } else if (this.ptr instanceof g.Message.Field) if (b.TYPE.test(this.ptr.type)) this.ptr.type =
                    d.TYPES[this.ptr.type]; else {
                        if (!b.TYPEREF.test(this.ptr.type)) throw Error("Illegal type reference in " + this.ptr.toString(!0) + ": " + this.ptr.type); a = this.ptr.parent.resolve(this.ptr.type, !0); if (!a) throw Error("Unresolvable type reference in " + this.ptr.toString(!0) + ": " + this.ptr.type); this.ptr.resolvedType = a; if (a instanceof g.Enum) this.ptr.type = d.TYPES["enum"]; else if (a instanceof g.Message) this.ptr.type = d.TYPES.message; else throw Error("Illegal type reference in " + this.ptr.toString(!0) + ": " + this.ptr.type);
                    } else if (!(this.ptr instanceof d.Reflect.Enum.Value)) if (this.ptr instanceof d.Reflect.Service.Method) if (this.ptr instanceof d.Reflect.Service.RPCMethod) {
                        a = this.ptr.parent.resolve(this.ptr.requestName); if (!(a && a instanceof d.Reflect.Message)) throw Error("Illegal request type reference in " + this.ptr.toString(!0) + ": " + this.ptr.requestName); this.ptr.resolvedRequestType = a; a = this.ptr.parent.resolve(this.ptr.responseName); if (!(a && a instanceof d.Reflect.Message)) throw Error("Illegal response type reference in " +
                        this.ptr.toString(!0) + ": " + this.ptr.responseName); this.ptr.resolvedResponseType = a
                    } else throw Error("Illegal service method type in " + this.ptr.toString(!0)); else throw Error("Illegal object type in namespace: " + typeof this.ptr + ":" + this.ptr); this.reset()
                }
            }; f.prototype.build = function (a) {
                this.reset(); this.resolved || (this.resolveAll(), this.resolved = !0, this.result = null); null == this.result && (this.result = this.ns.build()); if (a) {
                    a = a.split("."); for (var b = this.result, d = 0; d < a.length; d++) if (b[a[d]]) b = b[a[d]]; else {
                        b =
                        null; break
                    } return b
                } return this.result
            }; f.prototype.lookup = function (a) { return a ? this.ns.resolve(a) : this.ns }; f.prototype.toString = function () { return "Builder" }; f.Message = function () { }; f.Service = function () { }; return f
        }(g, g.Lang, g.Reflect); g.loadProto = function (d, b, m) { if ("string" == typeof b || b && "string" === typeof b.file && "string" === typeof b.root) m = b, b = null; return g.loadJson((new g.DotProto.Parser(d + "")).parse(), b, m) }; g.protoFromString = g.loadProto; g.loadProtoFile = function (d, b, m) {
            b && "object" === typeof b ? (m = b,
            b = null) : b && "function" === typeof b || (b = null); if (b) g.Util.fetch("object" === typeof d ? d.root + "/" + d.file : d, function (a) { b(g.loadProto(a, m, d)) }); else { var f = g.Util.fetch("object" === typeof d ? d.root + "/" + d.file : d); return null !== f ? g.protoFromString(f, m, d) : null }
        }; g.protoFromFile = g.loadProtoFile; g.newBuilder = function (d, b) { var m = new g.Builder; "undefined" !== typeof d && null !== d && m.define(d, b); return m }; g.loadJson = function (d, b, m) {
            if ("string" === typeof b || b && "string" === typeof b.file && "string" === typeof b.root) m = b, b = null;
            b && "object" === typeof b || (b = g.newBuilder()); "string" === typeof d && (d = JSON.parse(d)); b["import"](d, m); b.resolveAll(); b.build(); return b
        }; g.loadJsonFile = function (d, b, m) { b && "object" === typeof b ? (m = b, b = null) : b && "function" === typeof b || (b = null); if (b) g.Util.fetch("object" === typeof d ? d.root + "/" + d.file : d, function (a) { try { b(g.loadJson(JSON.parse(a), m, d)) } catch (c) { b(c) } }); else { var f = g.Util.fetch("object" === typeof d ? d.root + "/" + d.file : d); return null !== f ? g.loadJson(JSON.parse(f), m, d) : null } }; return g
    } "undefined" != typeof module &&
    module.exports ? module.exports = q(require("bytebuffer")) : "undefined" != typeof define && define.amd ? define("ProtoBuf", ["ByteBuffer"], q) : (p.dcodeIO || (p.dcodeIO = {}), p.dcodeIO.ProtoBuf = q(p.dcodeIO.ByteBuffer))
})(this);